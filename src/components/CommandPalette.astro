---
export interface Props {
  placeholder?: string
}

const { placeholder = 'Search commands...' } = Astro.props

import { getTopics } from '../content/content'
import { publishedNotes, publishedEssays, publishedTalks, stream } from '../content/content'

const allTopics = getTopics([publishedNotes, publishedEssays, publishedTalks, stream])
const sortedTopics = allTopics
  .sort((a, b) => a[0].localeCompare(b[0]))
  .sort((a, b) => b[1] - a[1])
---

<div
  id="command-palette"
  class="hidden fixed inset-0 z-50 items-center justify-center p-4"
>
  <div class="fixed inset-0 bg-black bg-opacity-50" id="palette-backdrop"></div>
  <div
    class="relative bg-zinc-900 rounded-lg shadow-xl w-full max-w-5xl border border-zinc-700 flex flex-col max-h-[90vh]"
  >
    <div class="border-b border-zinc-700 p-3">
      <div class="flex items-center gap-2 mb-2">
        <span class="text-xs text-zinc-500 uppercase">Filter by topics:</span>
        <button
          id="palette-clear-topics"
          class="text-xs text-cornflower hover:text-cornflower-light transition-opacity opacity-0 pointer-events-none"
        >
          Clear all
        </button>
      </div>
      <div id="palette-topics" class="flex flex-wrap gap-2 max-h-32 overflow-y-auto">
        {sortedTopics.map(([topic, count]) => (
          <button
            data-topic={topic}
            class="palette-topic-badge px-2 py-1 text-xs rounded-full border transition-colors
                   bg-zinc-800 border-zinc-600 text-zinc-300 hover:border-cornflower"
          >
            {topic} <span class="text-zinc-500">({count})</span>
          </button>
        ))}
      </div>
    </div>

    <div class="flex flex-1 min-h-0">
      <div class="flex-1 flex flex-col min-w-0">
        <input
          type="text"
          id="palette-input"
          class="w-full px-4 py-3 bg-transparent text-zinc-100 placeholder-zinc-500 outline-none border-b border-zinc-700"
          placeholder={placeholder}
          autocomplete="off"
        />
        <div id="palette-results" class="flex-1 overflow-y-auto"></div>
      </div>
      <div
        id="palette-preview"
        class="hidden w-96 border-l border-zinc-700 p-4 overflow-y-auto bg-zinc-950"
      >
        <div id="preview-content" class="text-sm text-zinc-400"></div>
      </div>
    </div>
  </div>
</div>

<script>
  import FlexSearch from 'flexsearch'
  import { $commandItems, selectedTopics } from '../store.ts'

  interface SearchResult {
    id: string
    type: string
    title: string
    description: string
    url: string
    body: string
    topics?: string[]
  }

  let isOpen = false
  let selectedIndex = 0
  let filteredItems: (CommandItem | SearchResult)[] = []
  let searchIndex: SearchResult[] = []
  let searchIndexLoaded = false
  let contentIndex: FlexSearch.Index | null = null
  let commandIndex: FlexSearch.Index | null = null

  const palette = document.getElementById('command-palette')!
  const input = document.getElementById('palette-input') as HTMLInputElement
  const results = document.getElementById('palette-results')!
  const backdrop = document.getElementById('palette-backdrop')!
  const previewPane = document.getElementById('palette-preview')!
  const previewContent = document.getElementById('preview-content')!
  const clearTopicsBtn = document.getElementById('palette-clear-topics')!

  async function loadSearchIndex() {
    if (searchIndexLoaded) return
    try {
      const response = await fetch('/api/search-index.json')
      searchIndex = await response.json()
      searchIndexLoaded = true

      contentIndex = new FlexSearch.Index({
        tokenize: 'forward',
        cache: true,
        context: {
          resolution: 9,
          depth: 2,
          bidirectional: true,
        },
      })

      searchIndex.forEach((item, idx) => {
        const searchableText = `${item.title} ${item.description} ${item.body}`
        contentIndex!.add(idx, searchableText)
      })
    } catch (error) {
      console.error('Failed to load search index:', error)
    }
  }

  function updateTopicBadges() {
    const selected = selectedTopics.get()
    const badges = document.querySelectorAll('.palette-topic-badge')
    
    badges.forEach((badge) => {
      const topic = (badge as HTMLElement).dataset.topic!
      if (selected.includes(topic)) {
        badge.classList.add('bg-cornflower', 'border-cornflower', 'text-zinc-900')
        badge.classList.remove('bg-zinc-800', 'border-zinc-600', 'text-zinc-300')
      } else {
        badge.classList.remove('bg-cornflower', 'border-cornflower', 'text-zinc-900')
        badge.classList.add('bg-zinc-800', 'border-zinc-600', 'text-zinc-300')
      }
    })

    if (selected.length > 0) {
      clearTopicsBtn.classList.remove('opacity-0', 'pointer-events-none')
      clearTopicsBtn.classList.add('opacity-100', 'pointer-events-auto')
    } else {
      clearTopicsBtn.classList.remove('opacity-100', 'pointer-events-auto')
      clearTopicsBtn.classList.add('opacity-0', 'pointer-events-none')
    }

    render()
  }

  function open() {
    isOpen = true
    palette.classList.remove('hidden')
    palette.classList.add('flex')
    input.focus()
    selectedIndex = 0
    loadSearchIndex()

    const commands = $commandItems.get()
    commandIndex = new FlexSearch.Index({
      tokenize: 'forward',
      cache: true,
    })

    commands.forEach((cmd, idx) => {
      const searchableText = `${cmd.name} ${cmd.description || ''} ${cmd.keywords?.join(' ') || ''}`
      commandIndex!.add(idx, searchableText)
    })

    updateTopicBadges()
    render()
  }

  function close() {
    isOpen = false
    palette.classList.add('hidden')
    palette.classList.remove('flex')
    input.value = ''
    selectedIndex = 0
    previewPane.classList.add('hidden')
  }

  function searchContent(query: string): SearchResult[] {
    if (!searchIndexLoaded || !contentIndex) return []

    const selected = selectedTopics.get()
    let results: SearchResult[]

    if (!query) {
      results = searchIndex
    } else {
      const indices = contentIndex.search(query, { limit: 50 })
      results = indices.map((idx) => searchIndex[idx as number])
    }

    if (selected.length > 0) {
      results = results.filter((item) => {
        const itemTopics = item.topics || []
        return itemTopics.some((topic) => selected.includes(topic))
      })
    }

    return results.slice(0, 10)
  }

  function searchCommands(query: string): CommandItem[] {
    const commands = $commandItems.get()
    if (!query || !commandIndex) return commands

    const results = commandIndex.search(query)
    return results.map((idx) => commands[idx as number])
  }

  function filter(query: string): (CommandItem | SearchResult)[] {
    const commands = searchCommands(query)
    const contentResults = searchContent(query)

    if (!query && selectedTopics.get().length === 0) return commands

    return [...commands, ...contentResults]
  }

  function isSearchResult(item: any): item is SearchResult {
    return 'url' in item && 'type' in item
  }

  function highlightMatches(text: string, query: string): string {
    if (!query) return text

    const terms = query.toLowerCase().split(/\s+/).filter(Boolean)
    let result = text

    terms.forEach((term) => {
      const regex = new RegExp(`(${term})`, 'gi')
      result = result.replace(
        regex,
        '<mark class="bg-yellow-600 text-zinc-100">$1</mark>',
      )
    })

    return result
  }

  function getContextSnippet(text: string, query: string): string {
    if (!query) return text.slice(0, 300) + '...'

    const terms = query.toLowerCase().split(/\s+/).filter(Boolean)
    const lowerText = text.toLowerCase()

    let bestIndex = -1
    let bestScore = 0

    for (let i = 0; i < lowerText.length; i++) {
      let score = 0
      terms.forEach((term) => {
        if (lowerText.slice(i, i + 100).includes(term)) {
          score++
        }
      })
      if (score > bestScore) {
        bestScore = score
        bestIndex = i
      }
    }

    if (bestIndex === -1) {
      return text.slice(0, 300) + '...'
    }

    const start = Math.max(0, bestIndex - 50)
    const end = Math.min(text.length, bestIndex + 250)
    const snippet = text.slice(start, end)

    return (start > 0 ? '...' : '') + snippet + (end < text.length ? '...' : '')
  }

  function updatePreview(item: CommandItem | SearchResult) {
    if (isSearchResult(item)) {
      const query = input.value
      const snippet = getContextSnippet(item.body, query)
      const highlighted = highlightMatches(snippet, query)

      previewContent.innerHTML = `
        <div class="mb-4">
          <div class="text-xs text-zinc-500 uppercase mb-1">${item.type}</div>
          <div class="text-lg font-medium text-zinc-100 mb-2">${item.title}</div>
          ${item.description ? `<div class="text-sm text-zinc-400 mb-3">${item.description}</div>` : ''}
          ${item.topics && item.topics.length > 0 ? `
            <div class="flex flex-wrap gap-1 mt-2">
              ${item.topics.map(topic => `<span class="text-xs px-2 py-0.5 rounded-full bg-zinc-800 text-zinc-400">${topic}</span>`).join('')}
            </div>
          ` : ''}
        </div>
        <div class="text-zinc-300 leading-relaxed whitespace-pre-wrap">${highlighted}</div>
      `
      previewPane.classList.remove('hidden')
    } else {
      previewContent.innerHTML = `
        <div class="mb-4">
          <div class="text-lg font-medium text-zinc-100 mb-2">${item.name}</div>
          ${item.description ? `<div class="text-sm text-zinc-400">${item.description}</div>` : ''}
        </div>
        ${item.keywords ? `<div class="text-xs text-zinc-500 mt-4">Keywords: ${item.keywords.join(', ')}</div>` : ''}
      `
      previewPane.classList.remove('hidden')
    }
  }

  function render() {
    const query = input.value
    filteredItems = filter(query)

    if (filteredItems.length === 0) {
      results.innerHTML =
        '<div class="px-4 py-8 text-center text-zinc-500">No results found</div>'
      previewPane.classList.add('hidden')
      return
    }

    results.innerHTML = filteredItems
      .map((item, index) => {
        const isSelected = index === selectedIndex

        if (isSearchResult(item)) {
          return `
            <div
              class="px-4 py-3 cursor-pointer transition-colors ${
                isSelected
                  ? 'bg-zinc-800 text-zinc-100'
                  : 'text-zinc-300 hover:bg-zinc-800'
              }"
              data-index="${index}"
            >
              <div class="flex items-center gap-2">
                <span class="text-xs px-2 py-0.5 rounded bg-zinc-700 text-zinc-400">${item.type}</span>
                <div class="font-medium">${item.title}</div>
              </div>
              ${item.description ? `<div class="text-sm text-zinc-500 mt-1">${item.description}</div>` : ''}
            </div>
          `
        } else {
          return `
            <div
              class="px-4 py-3 cursor-pointer transition-colors ${
                isSelected
                  ? 'bg-zinc-800 text-zinc-100'
                  : 'text-zinc-300 hover:bg-zinc-800'
              }"
              data-index="${index}"
            >
              <div class="font-medium">${item.name}</div>
              ${item.description ? `<div class="text-sm text-zinc-500">${item.description}</div>` : ''}
            </div>
          `
        }
      })
      .join('')

    results.querySelectorAll('[data-index]').forEach((el) => {
      el.addEventListener('click', () => {
        const index = parseInt((el as HTMLElement).dataset.index!)
        execute(filteredItems[index])
      })
    })

    if (filteredItems[selectedIndex]) {
      updatePreview(filteredItems[selectedIndex])
    }
  }

  function execute(item: CommandItem | SearchResult) {
    close()
    if (isSearchResult(item)) {
      window.location.href = item.url
    } else {
      item.handler()
    }
  }

  function moveSelection(delta: number) {
    selectedIndex = Math.max(
      0,
      Math.min(filteredItems.length - 1, selectedIndex + delta),
    )
    render()
  }

  document.querySelectorAll('.palette-topic-badge').forEach((badge) => {
    badge.addEventListener('click', () => {
      const topic = (badge as HTMLElement).dataset.topic!
      selectedTopics.set(
        selectedTopics.get().includes(topic)
          ? selectedTopics.get().filter((t) => t !== topic)
          : [...selectedTopics.get(), topic]
      )
    })
  })

  clearTopicsBtn.addEventListener('click', () => {
    selectedTopics.set([])
  })

  selectedTopics.subscribe(updateTopicBadges)

  document.addEventListener('keydown', (e) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
      e.preventDefault()
      if (isOpen) {
        close()
      } else {
        open()
      }
      return
    }

    if (!isOpen) return

    switch (e.key) {
      case 'Escape':
        e.preventDefault()
        close()
        break
      case 'ArrowDown':
        e.preventDefault()
        moveSelection(1)
        break
      case 'ArrowUp':
        e.preventDefault()
        moveSelection(-1)
        break
      case 'Enter':
        e.preventDefault()
        if (filteredItems[selectedIndex]) {
          execute(filteredItems[selectedIndex])
        }
        break
    }
  })

  input.addEventListener('input', () => {
    selectedIndex = 0
    render()
  })

  backdrop.addEventListener('click', close)

  render()
</script>
