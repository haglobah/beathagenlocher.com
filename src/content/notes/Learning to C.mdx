---
title: Learning to C
description: "A mastery guide for the ugly side of programming"
growthStage: seedling
startDate: 2025-07-29T00:52:40
updated: 2025-09-07T13:47:35
topics: [C, Programming, Learning]
publish: true
---

Would you like to learn to C?

Let's go.

# -1. This is not your normal guide

This guide is weird.

It's written to get a smart and persevering person started with the nitty-gritty side of programming that doesn't get discussed as often.

Its goal is to supply _a lot_ of information, tasks, and real-world projects while using real-world tools.
For example, this means that this guide will introduce `git` when I think the time has come (which is when you would encounter it in real life). `git`, therefore, will probably be introduced while doing a project.

For this, this guide will alternate between:
- Giving a high-level overview (where we're coming from, where we're going)
- And then diving into guides/projects
- Utilizing whatever good guide/task sheet/project description there already is.
- And supplying the things I found missing when I first learned all of this.

When following this guide, things should become harder and harder, but you shouldn't ever be clueless.
If that happens, it's not your fault, it's mine.
I just made a wild guess on how hard something would be which turned out to be wrong.
If that happens to you, it probably will happen to other people reading this, too.
When something irritates you, please [tell me about it](mailto:bah@posteo.de) so that I can correct it.
(Or, as soon as you're that advanced: Just open a pull request on GitHub ^^)

Remember, this guide assumes you're smart—behave like a smart person:
- Whenever you encounter a problem and have thought about it for a few minutes, _you google it_. (Good sites include StackOverflow)
- When you don't know how something works in general, try to read its documentation (online or via _man pages_—we'll get to that)
- When you really get stuck, _ask for help_. Ask people you know that might know the answer, or [just ask me directly](mailto:bah@posteo.de). When asking questions there's a few things to keep in mind: [1](https://dontasktoask.com/), [2](https://xyproblem.info/), and every site's got its own FAQ on asking ([StackOverflow](https://stackoverflow.com/help/how-to-ask), for example)

Oh, and just to do some expectation management up front: _Don't be fooled by how short this guide appears to be._
Expect that it will will be enough material for _months_.

# 0. Setup

## A. Unix

Get your hands on a [Unix](https://en.wikipedia.org/wiki/Unix) system.

This means either:
- [Installing WSL](https://www.youtube.com/watch?v=gTf32sX9ci0) (docs here: [https://learn.microsoft.com/en-us/windows/wsl/install](https://learn.microsoft.com/en-us/windows/wsl/install))
- Being on macOS—already done.
- Being on Linux—already done, too. :)

## B. Terminal

Open up a [Terminal Emulator](https://en.wikipedia.org/wiki/Terminal_emulator).

It should show something like this:

```shell
username@system:~ $
```

Verify everything works by typing your first shell command:

```shell
username@system:~ $ ls
```

This should _list_ the contents of your _home directory_—you should recognize some folder names.

And with that, we're ready for Part 1: Navigating the command line

# 1. Navigating the command line

Well, for navigating the command line, there's a pretty good guide available.

The way this is going to work is the following:

The next guide has chapters, and after enough content has been handled, I'll ask you spaced repetition questions to increase your learning.

1. Work through _1. Introducing the Shell_ and _2. Navigating Files and Directories_ of [The Unix Shell | Software Carpentry](https://swcarpentry.github.io/shell-novice/).

Done?

Time for a review:

<OrbitArea>
  <OrbitPrompt question="How do you find out your current working directory?" answer="`pwd`"/>
  <OrbitPrompt question="How do you show the contents of the current directory?" answer="`ls`"/>
  <OrbitPrompt question="How do you show the contents of the directory `/home/beat/`?" answer="`ls /home/beat/`"/>
  <OrbitPrompt question="How do you show the contents of the `lala` inside your current folder?" answer="`ls ./lala`"/>
  <OrbitPrompt question="How do you show the contents of the directory one level above the one you're currently in?" answer="`ls ..`"/>
  <OrbitPrompt question="Show all hidden files and folders." answer="`ls -a`"/>
  <OrbitPrompt question="Change into the directory `lala`." answer="`cd lala`"/>
  <OrbitPrompt question="Go one level up the directory tree." answer="`cd ..`"/>
  <OrbitPrompt question="Jump to your home directory." answer="`cd ~`"/>
  <OrbitPrompt question="Jump to the last visited directory." answer="`cd -`"/>
  <OrbitPrompt question="Assume you don't know anymore what `ls` does (and you don't have internet). How would you find help?"
  answer="- `ls --help`
  - `man ls`"/>
  <OrbitPrompt question="Let's do that for another command. How would you find out what `cp` does?"
  answer="- `cp --help`
  - `man cp`"/>
</OrbitArea>

That was [Orbit](https://withorbit.com/), a tool for blending learning with text.
This guide assumes that you know all of these questions from now on (and then for forever)—so, please, check your email regularly from now on :)

And with that, on to the next part: [3. Working With Files and Directories](https://swcarpentry.github.io/shell-novice/03-create.html#top)

Done?

Then it's review time, again:

<OrbitArea>
  <OrbitPrompt question="Create directory a directory called `this_dir`." answer="`mkdir this_dir`"/>
  <OrbitPrompt question="Create two directories consecutively: `outer_dir` and `inner_dir`." answer="`mkdir -p outer_dir/inner_dir`"/>
  <OrbitPrompt question="Create a new file (two ways)" answer="
  - `touch newfile`
  - `nano newfile`, follwed by `Ctrl+o` & `Ctrl+x`
  "/>
  <OrbitPrompt question="What are the ways tools indicate 'Hold Control, then press x'?" answer="
  - `Control-X`
  - `Control+X`
  - `Ctrl-X`
  - `Ctrl+X`
  - `^X`
  - `C-x`
  "/>
  <OrbitPrompt question="Delete a file" answer="`rm filepath`"/>
  <OrbitPrompt question="Delete a directory" answer="`rm -r mydir`"/>
  <OrbitPrompt question="Rename a file" answer="`mv oldname newname`"/>
  <OrbitPrompt question="Move a file" answer="`mv filepath destination_folder/`"/>
  <OrbitPrompt question="Copy all pdf files to `./pdfs/`" answer="`cp *.pdf ./pdfs/`"/>
</OrbitArea>

And on to [4. Pipes and Filters](https://swcarpentry.github.io/shell-novice/04-pipefilter.html):

<OrbitArea>
  <OrbitPrompt question="Print a file's contents to the shell" answer="`cat file.txt`"/>
  <OrbitPrompt question="Print a file's contents, but sort the lines" answer="`cat file.txt | sort`"/>
  <OrbitPrompt question="Print a file's contents, but sort the lines (now they contain numbers), and take only the last five lines" answer="`cat file.txt | sort -n | tail -n 5`"/>
  <OrbitPrompt question="Append one line to an existing file `file.txt` (not using an editor)" answer="`echo 'the new line' >> file.txt`"/>
  <OrbitPrompt question="Show the first 10 lines of a file" answer="`head file.txt`"/>
  <OrbitPrompt question="Show the last 3 lines of a file" answer="`tail -n 3 file.txt`"/>
  <OrbitPrompt question="Count the number of lines in a file" answer="`wc -l file.txt`"/>
  <OrbitPrompt question="Count the number of words in a file" answer="`wc -w file.txt`"/>
  <OrbitPrompt question="Remove duplicate lines from sorted output" answer="`sort file.txt | uniq`"/>
  <OrbitPrompt question="Save the output of a command to a file (overwriting)" answer="`command > output.txt`"/>
  <OrbitPrompt question="Save the output of a command to a file (appending)" answer="`command >> output.txt`"/>
  <OrbitPrompt question="What does the pipe operator `|` do?" answer="Takes the output of the command on the left and uses it as input for the command on the right"/>
</OrbitArea>

Continue with [5. Loops](https://swcarpentry.github.io/shell-novice/05-loop.html):

<OrbitArea>
  <OrbitPrompt question="Write a for loop that prints each file name in the current directory" answer="`for filename in *; do echo $filename; done`"/>
  <OrbitPrompt question="Write a for loop that copies all .txt files to a backup directory" answer="`for file in *.txt; do cp $file backup/; done`"/>
  <OrbitPrompt question="How do you reference a variable in bash?" answer="Use `$` before the variable name, like `$filename`"/>
  <OrbitPrompt question="Write a for loop that processes files alice.txt and bob.txt" answer="`for file in alice.txt bob.txt; do echo $file; done`"/>
  <OrbitPrompt question="What's the general syntax of a for loop in bash?" answer="`for variable in list; do commands; done`"/>
</OrbitArea>

Continue with [6. Shell Scripts](https://swcarpentry.github.io/shell-novice/06-script.html):

<OrbitArea>
  <OrbitPrompt question="What's the first line you should put in a bash script?" answer="`#!/bin/bash` (the shebang line)"/>
  <OrbitPrompt question="How do you make a script executable?" answer="`chmod +x script.sh`"/>
  <OrbitPrompt question="How do you access the first command line argument in a script?" answer="`$1`"/>
  <OrbitPrompt question="How do you access the second command line argument in a script?" answer="`$2`"/>
  <OrbitPrompt question="How do you access all command line arguments in a script?" answer="`$@`"/>
  <OrbitPrompt question="How do you run a script called `myscript.sh` in the current directory?" answer="`./myscript.sh`"/>
  <OrbitPrompt question="What does `$0` contain in a script?" answer="The name of the script itself"/>
</OrbitArea>

Continue with [7. Finding Things](https://swcarpentry.github.io/shell-novice/07-find.html):

<OrbitArea>
  <OrbitPrompt question="Find all files with .txt extension in the current directory and subdirectories" answer="`find . -name '*.txt'`"/>
  <OrbitPrompt question="Find all directories named 'data'" answer="`find . -type d -name 'data'`"/>
  <OrbitPrompt question="Find all files named *.log" answer="`find . -type f -name *.md`"/>
  <OrbitPrompt question="Search for the word 'TODO' in all `.py` files" answer="`grep 'TODO' *.py`"/>
  <OrbitPrompt question="Count the number of lines with 'TODO' in all `.py` files" answer="`grep 'TODO' *.py | wc --lines`"/>
  <OrbitPrompt question="Filter out all the lines that contain 'TODO' in all `.py` files" answer="`grep -v 'TODO' *.py`"/>
  <OrbitPrompt question="Search for 'function' in all files recursively" answer="`grep --recursive 'function' .`"/>
  <OrbitPrompt question="Search for 'error' case-insensitively" answer="`grep --ignore-case 'error' file.txt`"/>
  <OrbitPrompt question="Show line numbers when searching with grep" answer="`grep --line-number 'pattern' file.txt`"/>
</OrbitArea>

Aand: Done!

But now, to really test your knowledge:  
> Complete the [Twelve days of shell](https://12days.cmdchallenge.com/), and, if you're feeling adventurous, as much of the [cmdchallenge](https://cmdchallenge.com/) as you can (or want to) do.

And then, on to other things.

# Intermezzo: Installing stuff

So far, everything you needed to use came preinstalled with your Operating System.

This is about to change.

At the end of this intermezzo, we'd like to have the program `gcc` (one of the C compilers) "installed".
At least that's the term you probably know from Graphical User Interface (GUI) programs.

For our intents and purposes here, _installing a program_ means "making it available for execution". So, installing a program yields this difference:

Uninstalled:

```shell
$ hello
Command not found: "hello"
```

And installed:

```shell
$ hello
Hello, World
```

The normal way to do this would be to install the package via your OS package manager (most probably `apt`), but we won't do that here.  
To exclude a <Il href="works-on-my-machine">whole class of problems</Il> from happening whatsoever, we will install things via [[Nix]].

So, let's get back to your terminal window, and install [[Nix]]:

```shell
curl -fsSL https://install.determinate.systems/nix | sh -s -- install
```

After completing the installation process, you should be able to run

```shell
nix --help
```

and see the help.

With that out of the way, back to our original problem: Installing `gcc`.

- Create a new folder in `~`: `learning-to-c`
- Create a new file in that folder: `flake.nix`
- Start editing that file (you now know how). It should end up with the following content:

```nix
{
  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs?ref=nixos-unstable";
  };

  outputs =
    inputs@{
      flake-parts,
      self,
      ...
    }:
    flake-parts.lib.mkFlake { inherit inputs; } {
      systems = [
        "x86_64-linux"
        "aarch64-linux"
        "aarch64-darwin"
        "x86_64-darwin"
      ];
      perSystem =
        {
          config,
          self',
          inputs',
          pkgs,
          system,
          ...
        }:
        {
          _module.args.pkgs = import self.inputs.nixpkgs {
            inherit system;
            config.allowUnfree = true;
          };

          devShells.default = pkgs.mkShell {
            packages = [
              # interesting part is here.
            ];
          };
        };
    };
}
```

Now, add the package `hello` to the package list:

```nix
packages = [
  pkgs.hello
]
```

Test whether `hello` exists:

```shell
$ which hello
which: no hello in (...)
```

But it doesn't.

For that to happen, we need to enter the so-called _Nix Development Shell_ we just defined in our `flake.nix`:

```shell
nix develop
```

This puts you in a new shell that has `hello` available:

```shell
$ which hello
/nix/store/...-hello-2.12.2/bin/hello
# Verify that it works:
$ hello
Hello, World!
```

Okay, nice.  
And now, let's finally install `gcc`.

```nix
packages = [
  pkgs.hello
  pkgs.gcc15
]
```

Another `nix develop` and it should be there:

```shell
$ which gcc
/nix/store/1d75h3ii...-gcc-wrapper-15.1.0/bin/gcc
```

And we've installed gcc.

Review time :)

<OrbitArea>
  <OrbitPrompt question="What does 'installing a program' mean in the context of command line tools?" answer="Making it available for execution - so you can run the command from anywhere"/>
  <OrbitPrompt question="What file defines a Nix development environment?" answer="`flake.nix`"/>
  <OrbitPrompt question="How do you enter a Nix development shell?" answer="`nix develop`"/>
  <OrbitPrompt question="How do you check if a command is available and where it's located?" answer="`which commandname`"/>
  <OrbitPrompt question="In a Nix flake, where do you specify which packages should be available in your development shell?" answer="In the `packages = [ ... ]` list inside `devShells.default`"/>
</OrbitArea>


# 2. C basics, Part I

## Hello World

Okay, so now we've finally got a C compiler available. Let's write our first C program, and compile it with it.

You know the drill by now:
1. Open up an editor
2. Write the program
3. Save the file

So, staying in the directory with the `flake.nix` file, _after_ you've executed `nix develop`:

```shell
nano main.c
```

Add the following content:

```c
#include <stdio.h>

int main() {
  printf("Hello, World!");
  return (0);
}
```


Save the file, And then, compile it:

```shell
gcc main.c
```

This produces a new file `a.out` you can execute via:

```shell
./a.out
Hello, World!⏎
```

And with this, you've completed the first part of basically any programming language introduction: The [Hello, World! program](https://en.wikipedia.org/wiki/%22Hello,_World!%22_program)

<Callout>
Now, let's take some time to practice reading unfamiliar code.
When trying to read unfamiliar code, you should:

1. Check what you don't understand
2. Find out what to google
3. Google that
4. Try to explain the piece of code to yourself.

<ListMarker>1.</ListMarker>, you need to do yourself.  
For <ListMarker>2.</ListMarker>, [[LLM]]s can be quite helpful.  
<ListMarker>3.</ListMarker> just needs proper googling, and <ListMarker>4.</ListMarker>, you can only do yourself (again).

In our example, that might mean:

1. Getting that you don't understand what happening on the first line
2. Asking claude what up with that, and it telling you that this tells the _C preprocessor_ to include a _header file_.
3. Googling something among the lines of "C include statement", "C header file", "C preprocessor", "C preprocessor header file", "C header file example"
4. And with this newfound knowledge: Trying to explain it again :)
</Callout>

Now: Well, _do that_.

And when you're finished: Review time! :)

<OrbitArea>
  <OrbitPrompt question="What's the file extension for C source code files?" answer="`.c`"/>
  <OrbitPrompt question="How do you compile a C file called `main.c` using gcc?" answer="`gcc main.c`"/>
  <OrbitPrompt question="What's the default name of the executable file created by gcc?" answer="`a.out`"/>
  <OrbitPrompt question="How do you run an executable file called `a.out` in the current directory?" answer="`./a.out`"/>
  <OrbitPrompt question="What does `#include <stdio.h>` do in a C program?" answer="It tells the C preprocessor to include the standard input/output header file"/>
  <OrbitPrompt question="What does the `main()` function return in a typical C program?" answer="An integer (usually 0 for success)"/>
  <OrbitPrompt question="What C function is used to print text to the console?" answer="`printf()`"/>
  <OrbitPrompt question="Write the basic structure of a Hello World program in C." answer='```c
#include <stdio.h>

int main() {
  printf("Hello, World!\");
  return (0);
}
```'/>

</OrbitArea>

<Draft>

# Intermezzo: Editor

Using `nano` surely has gotten a bit tedious by this point. Right?

Let's fix that and use an editor people actually use as their daily driver: Visual Studio Code (NeoVim/Emacs will come later in this guide)

- Install VSCode
- depending on windows/unix, setup conection to WSL
- install the C extension
- open up the project

And, just so that you've seen it once:

VSCode is pretty configurable, actually: The editor and extensions itself use two files, `keybindings.json` and `config.json` to do most of the stuff.

And with that: Onto some more functions.

# 3. C basics, Part II

- syscalls
- strcmp
- putchar

# Intermezzo: Version Control

So far, you've only worked locally on one state of your file system.

In the future, you might want to:
- work on different PCs
- collaborate on a codebase with different people
- jump back in time
- work on several avenue/features/chunks of code separately

For all of this, we'll use something called [[Version Control]].
The main _Version Control System_ in distribution is something called _Git_.

- With Git, you have repositories in which your code lives (similar to folders in which you can branch and time travel)
- in those repositories, you store a snapshot of the folder in time (that's called a _commit_)
- those commits form a directed acyclic graph
- you can traverse and manipulate this graph
- you can have these graphs on different machines by adding _remotes_

Git has a command line tool, `git`, with which all of this happens.

Let's start and use it.

First, install it. (Pause here and think: How can you install things again?)

<Spoiler>

Go to your `flake.nix` and add the following (gotten through searching `git` on https://search.nixos.org/)

```nix
packages = [
  # ...other packages
  pkgs.git
]
```

</Spoiler>



# Intermezzo: Testing

# Intermezzo: Shell aliases

# Intermezzo: Fish shell (+ abbreviations)

</Draft>
